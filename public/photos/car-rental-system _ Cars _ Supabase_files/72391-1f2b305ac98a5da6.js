try{!function(){var n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},e=(new n.Error).stack;e&&(n._sentryDebugIds=n._sentryDebugIds||{},n._sentryDebugIds[e]="a2fa2f54-6e5d-4689-a64f-2ec8fb98523d",n._sentryDebugIdIdentifier="sentry-dbid-a2fa2f54-6e5d-4689-a64f-2ec8fb98523d")}()}catch(n){}"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[72391],{72391:(n,e,t)=>{t.d(e,{A:()=>nz});var a={};t.r(a),t.d(a,{create:()=>L,list:()=>w,remove:()=>O,retrieve:()=>j,update:()=>Y});var o={};t.r(o),t.d(o,{create:()=>H,list:()=>z,pgFunctionArrayZod:()=>k,pgFunctionCreateZod:()=>F,pgFunctionDeleteZod:()=>P,pgFunctionOptionalZod:()=>M,pgFunctionUpdateZod:()=>B,pgFunctionZod:()=>x,remove:()=>W,retrieve:()=>U,update:()=>$});var c=t(29395);let i='\n-- Can\'t use pg_authid here since some managed Postgres providers don\'t expose it\n-- https://github.com/supabase/postgres-meta/issues/212\n\nselect\n  r.oid as id,\n  rolname as name,\n  rolsuper as "isSuperuser",\n  rolcreatedb as "canCreateDb",\n  rolcreaterole as "canCreateRole",\n  rolinherit as "inheritRole",\n  rolcanlogin as "canLogin",\n  rolreplication as "isReplicationRole",\n  rolbypassrls as "canBypassRls",\n  (\n    select\n      count(*)\n    from\n      pg_stat_activity\n    where\n      r.rolname = pg_stat_activity.usename\n  ) as "activeConnections",\n  case when rolconnlimit = -1 then current_setting(\'max_connections\') :: int8\n       else rolconnlimit\n  end as "connectionLimit",\n  rolvaliduntil as "validUntil",\n  coalesce(r_config.role_configs, \'{}\') as config\nfrom\n  pg_roles r\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as role_configs\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(rolconfig), \'=\'))[1] as param,\n          (string_to_array(unnest(rolconfig), \'=\'))[2] as value\n        from\n          pg_roles\n      ) as _\n    group by\n      oid\n  ) r_config on r_config.oid = r.oid\n';var r=t(10663);let l=r.Ik({id:r.ai(),name:r.Yj(),isSuperuser:r.zM(),canCreateDb:r.zM(),canCreateRole:r.zM(),inheritRole:r.zM(),canLogin:r.zM(),isReplicationRole:r.zM(),canBypassRls:r.zM(),activeConnections:r.ai(),connectionLimit:r.ai(),validUntil:r.KC([r.Yj(),r.ch()]),config:r.g1(r.Yj(),r.Yj())}),s=r.YO(l),d=r.lq(l);function m(n){if("id"in n&&n.id)return"".concat((0,c.bD)("id")," = ").concat((0,c.eu)(n.id));if("name"in n&&n.name)return"".concat((0,c.bD)("name")," = ").concat((0,c.eu)(n.name));throw Error("Must provide either id or name")}var p=t(78510);let u=(n,e)=>"\nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(".concat(n,")) FILTER (WHERE ").concat(e,")\n    FROM\n      ").concat(n,"\n  ),\n  '{}'\n) AS ").concat(n);function _(n,e,t){return(t&&(e=t.concat(null!=e?e:[])),null==n?void 0:n.length)?"IN (".concat(n.map(c.eu).join(","),")"):(null==e?void 0:e.length)?"NOT IN (".concat(e.map(c.eu).join(","),")"):""}let g="\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || '.' || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE NULL\n  END AS default_value,\n  CASE\n    WHEN t.typtype = 'd' THEN CASE\n      WHEN bt.typelem <> 0 :: oid\n      AND bt.typlen = -1 THEN 'ARRAY'\n      WHEN nbt.nspname = 'pg_catalog' THEN format_type(t.typbasetype, NULL)\n      ELSE 'USER-DEFINED'\n    END\n    ELSE CASE\n      WHEN t.typelem <> 0 :: oid\n      AND t.typlen = -1 THEN 'ARRAY'\n      WHEN nt.nspname = 'pg_catalog' THEN format_type(a.atttypid, NULL)\n      ELSE 'USER-DEFINED'\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ('a', 'd') AS is_identity,\n  CASE\n    a.attidentity\n    WHEN 'a' THEN 'ALWAYS'\n    WHEN 'd' THEN 'BY DEFAULT'\n    ELSE NULL\n  END AS identity_generation,\n  a.attgenerated IN ('s') AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = 'd' AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ('r', 'p')\n    OR c.relkind IN ('v', 'f') AND pg_column_is_updatable(c.oid, a.attnum, FALSE)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = 'd'\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[1] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = 'u' AND cardinality(conkey) = 1\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[1] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, true),\n        8,\n        length(pg_get_constraintdef(pg_constraint.oid, true)) - 8\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = 'c' AND cardinality(conkey) = 1\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > 0\n  AND NOT a.attisdropped\n  AND (c.relkind IN ('r', 'v', 'm', 'f', 'p'))\n  AND (\n    pg_has_role(c.relowner, 'USAGE')\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      'SELECT, INSERT, UPDATE, REFERENCES'\n    )\n  )\n",b=r.Ik({id:r.Yj(),table_id:r.ai(),schema:r.Yj(),table:r.Yj(),name:r.Yj(),ordinal_position:r.ai(),data_type:r.Yj(),format:r.Yj(),is_identity:r.zM(),identity_generation:r.Yj().nullable(),is_generated:r.zM(),is_nullable:r.zM(),is_updatable:r.zM(),is_unique:r.zM(),check:r.Yj().nullable(),default_value:r.bz().nullable(),enums:r.YO(r.Yj()),comment:r.Yj().nullable()}),f=r.YO(b),h=r.lq(b),E=n=>n.endsWith("[]")?"".concat((0,c.bD)(n.slice(0,-2)),"[]"):n.includes(".")?n:(0,c.bD)(n),A="\n-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, 'USAGE')\n    or has_schema_privilege(n.oid, 'CREATE, USAGE')\n  )\n  and not pg_catalog.starts_with(n.nspname, 'pg_temp_')\n  and not pg_catalog.starts_with(n.nspname, 'pg_toast_temp_')\n",v=r.Ik({id:r.ai(),name:r.Yj(),owner:r.Yj()}),N=r.YO(v),T=r.lq(v),D=r.Ik({table_id:r.ai(),name:r.Yj(),schema:r.Yj(),table_name:r.Yj()}),y=r.Ik({id:r.ai(),constraint_name:r.Yj(),source_schema:r.Yj(),source_table_name:r.Yj(),source_column_name:r.Yj(),target_table_schema:r.Yj(),target_table_name:r.Yj(),target_column_name:r.Yj()}),I=r.Ik({id:r.ai(),schema:r.Yj(),name:r.Yj(),rls_enabled:r.zM(),rls_forced:r.zM(),replica_identity:r.k5(["DEFAULT","INDEX","FULL","NOTHING"]),bytes:r.ai(),size:r.Yj(),live_rows_estimate:r.ai(),dead_rows_estimate:r.ai(),comment:r.Yj().nullable(),primary_keys:r.YO(D),relationships:r.YO(y),columns:f.optional()}),S=r.YO(I);function w(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o,includeColumns:c=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=R({includeColumns:c}),r=_(e,t,n?void 0:p.h);return r&&(i+=" where schema ".concat(r)),a&&(i+=" limit ".concat(a)),o&&(i+=" offset ".concat(o)),{sql:i,zod:S}}function j(n){let e=function(n){if("id"in n&&n.id)return"".concat((0,c.bD)("id")," = ").concat((0,c.eu)(n.id));if("name"in n&&n.name&&n.schema)return"".concat((0,c.bD)("name")," = ").concat((0,c.eu)(n.name)," and ").concat((0,c.bD)("schema")," = ").concat((0,c.eu)(n.schema));throw Error("Must provide either id or name and schema")}(n);return{sql:"".concat(R({includeColumns:!0})," where ").concat(e,";"),zod:I}}function O(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"DROP TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.name)," ").concat(e?"CASCADE":"RESTRICT",";")}}let R=n=>{let{includeColumns:e}=n;return"\n  with tables as (".concat("\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = 'd' THEN 'DEFAULT'\n    WHEN c.relreplident = 'i' THEN 'INDEX'\n    WHEN c.relreplident = 'f' THEN 'FULL'\n    ELSE 'NOTHING'\n  END AS replica_identity,\n  pg_total_relation_size(format('%I.%I', nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format('%I.%I', nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, '[]') as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    '[]'\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          'table_id', c.oid::int8,\n          'schema', n.nspname,\n          'table_name', c.relname,\n          'name', a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = 'f'\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ('r', 'p')\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, 'USAGE')\n    OR has_table_privilege(\n      c.oid,\n      'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'\n    )\n    OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES')\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n",")\n  ").concat(e?", columns as (".concat(g,")"):"","\n  select\n    *\n    ").concat(e?", ".concat(u("columns","columns.table_id = tables.id")):"","\n  from tables")};function L(n){let{name:e,schema:t="public",comment:a}=n,o="CREATE TABLE ".concat((0,c.bD)(t),".").concat((0,c.bD)(e)," ();"),i=void 0!=a?"COMMENT ON TABLE ".concat((0,c.bD)(t),".").concat((0,c.bD)(e)," IS ").concat((0,c.eu)(a),";"):"";return{sql:"BEGIN; ".concat(o," ").concat(i," COMMIT;")}}function Y(n,e){let{name:t,schema:a,rls_enabled:o,rls_forced:i,replica_identity:r,replica_identity_index:l,primary_keys:s,comment:d}=e,m="ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.name)),p=void 0===a?"":"".concat(m," SET SCHEMA ").concat((0,c.bD)(a),";"),u="";if(void 0!==t&&t!==n.name){let e=void 0===a?n.schema:a;u="ALTER TABLE ".concat((0,c.bD)(e),".").concat((0,c.bD)(n.name)," RENAME TO ").concat((0,c.bD)(t),";")}let _="";void 0!==o&&(_=o?"".concat(m," ENABLE ROW LEVEL SECURITY;"):"".concat(m," DISABLE ROW LEVEL SECURITY;"));let g="";void 0!==i&&(g=i?"".concat(m," FORCE ROW LEVEL SECURITY;"):"".concat(m," NO FORCE ROW LEVEL SECURITY;"));let b="";void 0===r||(b="INDEX"===r?"".concat(m," REPLICA IDENTITY USING INDEX ").concat(l,";"):"".concat(m," REPLICA IDENTITY ").concat(r,";"));let f="";void 0===s||(f+="\nDO $$\nDECLARE\n  r record;\nBEGIN\n  SELECT conname\n    INTO r\n    FROM pg_constraint\n    WHERE contype = 'p' AND conrelid = ".concat((0,c.eu)(n.id),";\n  IF r IS NOT NULL THEN\n    EXECUTE ").concat((0,c.eu)("".concat(m," DROP CONSTRAINT "))," || quote_ident(r.conname);\n  END IF;\nEND\n$$;\n"),0===s.length||(f+="".concat(m," ADD PRIMARY KEY (").concat(s.map(n=>(0,c.bD)(n.name)).join(","),");")));let h=void 0==d?"":"COMMENT ON TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.name)," IS ").concat((0,c.eu)(d),";");return{sql:"\nBEGIN;\n  ".concat(_,"\n  ").concat(g,"\n  ").concat(b,"\n  ").concat(f,"\n  ").concat(h,"\n  ").concat(p,"\n  ").concat(u,"\nCOMMIT;")}}let C="\n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill('i'::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill(''::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill(false, array[pronargs - pronargdefaults]),\n      array_fill(true, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = 'f'\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = 'internal' then ''\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = 'internal' then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, '[]') as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, 0) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = 'i' then 'IMMUTABLE'\n    when f.provolatile = 's' then 'STABLE'\n    when f.provolatile = 'v' then 'VOLATILE'\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), '='))[1] as param,\n          (string_to_array(unnest(proconfig), '='))[2] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        'mode', t2.mode,\n        'name', name,\n        'type_id', type_id,\n        -- Cast null into false boolean\n        'has_default', COALESCE(has_default, false)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = 'i' then 'in'\n            when t1.mode = 'o' then 'out'\n            when t1.mode = 'b' then 'inout'\n            when t1.mode = 'v' then 'variadic'\n            else 'table'\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n",x=r.Ik({id:r.ai(),schema:r.Yj(),name:r.Yj(),language:r.Yj(),definition:r.Yj(),complete_statement:r.Yj(),args:r.YO(r.Ik({mode:r.KC([r.eu("in"),r.eu("out"),r.eu("inout"),r.eu("variadic"),r.eu("table")]),name:r.Yj(),type_id:r.ai(),has_default:r.zM()})),argument_types:r.Yj(),identity_argument_types:r.Yj(),return_type_id:r.ai(),return_type:r.Yj(),return_type_relation_id:r.KC([r.ai(),r.ch()]),is_set_returning_function:r.zM(),behavior:r.KC([r.eu("IMMUTABLE"),r.eu("STABLE"),r.eu("VOLATILE")]),security_definer:r.zM(),config_params:r.KC([r.g1(r.Yj(),r.Yj()),r.ch()])}),k=r.YO(x),M=r.lq(x);function z(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},c="\n    with f as (\n      ".concat(C,"\n    )\n    select\n      f.*\n    from f\n  "),i=_(e,t,n?void 0:p.h);return i&&(c+=" where schema ".concat(i)),a&&(c="".concat(c," limit ").concat(a)),o&&(c="".concat(c," offset ").concat(o)),{sql:c,zod:k}}function U(n){let{id:e,name:t,schema:a="public",args:o=[]}=n;if(e)return{sql:"\n      with f as (\n        ".concat(C,"\n      )\n      select\n        f.*\n      from f where id = ").concat((0,c.eu)(e),";"),zod:M};if(t&&a&&o)return{sql:"with f as (\n      ".concat(C,"\n    )\n    select\n      f.*\n    from f join pg_proc as p on id = p.oid where schema = ").concat((0,c.eu)(a)," and name = ").concat((0,c.eu)(t)," and p.proargtypes::text = ").concat(o.length?"(\n          select string_agg(type_oid::text, ' ') from (\n            select (\n              split_args.arr[\n                array_length(\n                  split_args.arr,\n                  1\n                )\n              ]::regtype::oid\n            ) as type_oid from (\n              select string_to_array(\n                unnest(\n                  array[".concat(o.map(c.eu),"]\n                ),\n                ' '\n              ) as arr\n            ) as split_args\n          ) args\n        )"):(0,c.eu)("")),zod:M};throw Error("Must provide either id or name and schema")}let F=r.Ik({name:r.Yj(),definition:r.Yj(),args:r.YO(r.Yj()).optional(),behavior:r.k5(["IMMUTABLE","STABLE","VOLATILE"]).optional(),config_params:r.g1(r.Yj(),r.Yj()).optional(),schema:r.Yj().optional(),language:r.Yj().optional(),return_type:r.Yj().optional(),security_definer:r.zM().optional()});function q(n){let{name:e,schema:t,args:a,definition:o,return_type:i,language:r,behavior:l,security_definer:s,config_params:d}=n,{replace:m=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"\n    CREATE ".concat(m?"OR REPLACE":""," FUNCTION ").concat((0,c.bD)(t),".").concat((0,c.bD)(e),"(").concat((null==a?void 0:a.join(", "))||"",")\n    RETURNS ").concat(i,"\n    AS ").concat((0,c.eu)(o),"\n    LANGUAGE ").concat(r,"\n    ").concat(l,"\n    CALLED ON NULL INPUT\n    ").concat(s?"SECURITY DEFINER":"SECURITY INVOKER","\n    ").concat(d?Object.entries(d).map(n=>{let[e,t]=n;return"SET ".concat(e," ").concat("FROM CURRENT"===t?"FROM CURRENT":"TO "+('""'===t?"''":t))}).join("\n"):"",";\n  ")}function H(n){let{name:e,schema:t="public",args:a=[],definition:o,return_type:c="void",language:i="sql",behavior:l="VOLATILE",security_definer:s=!1,config_params:d={}}=n;return{sql:q({name:e,schema:t,args:a,definition:o,return_type:c,language:i,behavior:l,security_definer:s,config_params:d}),zod:r.rI()}}let B=r.Ik({name:r.Yj().optional(),schema:r.Yj().optional(),definition:r.Yj().optional()});function $(n,e){var t;let{name:a,schema:o,definition:i}=e,l=n.argument_types.split(", "),s=n.identity_argument_types,d="string"==typeof i?q({...n,definition:i,args:l,config_params:null!=(t=n.config_params)?t:{}},{replace:!0}):"",m=a&&a!==n.name?"ALTER FUNCTION ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.name),"(").concat(s,") RENAME TO ").concat((0,c.bD)(a),";"):"",p=o&&o!==n.schema?"ALTER FUNCTION ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(a||n.name),"(").concat(s,")  SET SCHEMA ").concat((0,c.bD)(o),";"):"";return{sql:"\n    DO LANGUAGE plpgsql $$\n    BEGIN\n      IF ".concat("string"==typeof i?"TRUE":"FALSE"," THEN\n        ").concat(d,"\n\n        IF (\n          SELECT id\n          FROM (").concat(C,") AS f\n          WHERE f.schema = ").concat((0,c.eu)(n.schema),"\n          AND f.name = ").concat((0,c.eu)(n.name),"\n          AND f.identity_argument_types = ").concat((0,c.eu)(s),"\n        ) != ").concat(n.id," THEN\n          RAISE EXCEPTION 'Cannot find function \"").concat(n.schema,'"."').concat(n.name,'"(').concat(s,")';\n        END IF;\n      END IF;\n\n      ").concat(m,"\n\n      ").concat(p,"\n    END;\n    $$;\n  "),zod:r.rI()}}let P=r.Ik({cascade:r.zM().default(!1).optional()});function W(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"DROP FUNCTION ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.name),"\n  (").concat(n.identity_argument_types,")\n  ").concat(e?"CASCADE":"RESTRICT",";"),zod:r.rI()}}let G="\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = 'r' then 'table'\n    when c.relkind = 'v' then 'view'\n    when c.relkind = 'm' then 'materialized_view'\n    when c.relkind = 'f' then 'foreign_table'\n    when c.relkind = 'p' then 'partitioned_table'\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        'grantor', grantor.rolname,\n        'grantee', grantee.rolname,\n        'privilege_type', _priv.privilege_type,\n        'is_grantable', _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    '[]'\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault('r', c.relowner)))\n) as _priv on true\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    (0)::oid as oid, 'PUBLIC'\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ('r', 'v', 'm', 'f', 'p')\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, 'USAGE')\n    or has_table_privilege(\n      c.oid,\n      'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'\n      || case when current_setting('server_version_num')::int4 >= 170000 then ', MAINTAIN' else '' end\n    )\n    or has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES')\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n",J=r.Ik({relation_id:r.ai(),schema:r.Yj(),name:r.Yj(),kind:r.KC([r.eu("table"),r.eu("view"),r.eu("materialized_view"),r.eu("foreign_table"),r.eu("partitioned_table")]),privileges:r.YO(r.Ik({grantor:r.Yj(),grantee:r.Yj(),privilege_type:r.KC([r.eu("SELECT"),r.eu("INSERT"),r.eu("UPDATE"),r.eu("DELETE"),r.eu("TRUNCATE"),r.eu("REFERENCES"),r.eu("TRIGGER"),r.eu("MAINTAIN")]),is_grantable:r.zM()}))}),K=r.YO(J),V=r.lq(J),X="\nSELECT\n  p.oid :: int8 AS id,\n  p.pubname AS name,\n  p.pubowner::regrole::text AS owner,\n  p.pubinsert AS publish_insert,\n  p.pubupdate AS publish_update,\n  p.pubdelete AS publish_delete,\n  p.pubtruncate AS publish_truncate,\n  CASE\n    WHEN p.puballtables THEN NULL\n    ELSE pr.tables\n  END AS tables\nFROM\n  pg_catalog.pg_publication AS p\n  LEFT JOIN LATERAL (\n    SELECT\n      COALESCE(\n        array_agg(\n          json_build_object(\n            'id',\n            c.oid :: int8,\n            'name',\n            c.relname,\n            'schema',\n            nc.nspname\n          )\n        ),\n        '{}'\n      ) AS tables\n    FROM\n      pg_catalog.pg_publication_rel AS pr\n      JOIN pg_class AS c ON pr.prrelid = c.oid\n      join pg_namespace as nc on c.relnamespace = nc.oid\n    WHERE\n      pr.prpubid = p.oid\n  ) AS pr ON 1 = 1\n",Z=r.Ik({id:r.ai().optional(),name:r.Yj(),schema:r.Yj()}),Q=r.Ik({id:r.ai(),name:r.Yj(),owner:r.Yj(),publish_insert:r.zM(),publish_update:r.zM(),publish_delete:r.zM(),publish_truncate:r.zM(),tables:r.YO(Z).nullable()}),nn=r.YO(Q),ne=r.lq(Q),nt="\nSELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\n",na=r.Ik({name:r.Yj(),schema:r.Yj().nullable(),default_version:r.Yj(),installed_version:r.Yj().nullable(),comment:r.Yj()}),no=r.YO(na),nc=r.lq(na),ni=r.Ik({name:r.Yj(),setting:r.Yj(),category:r.Yj(),group:r.Yj(),subgroup:r.Yj(),unit:r.Yj().nullable(),short_desc:r.Yj(),extra_desc:r.Yj().nullable(),context:r.Yj(),vartype:r.Yj(),source:r.Yj(),min_val:r.Yj().nullable(),max_val:r.Yj().nullable(),enumvals:r.YO(r.Yj()).nullable(),boot_val:r.Yj().nullable(),reset_val:r.Yj().nullable(),sourcefile:r.Yj().nullable(),sourceline:r.ai().nullable(),pending_restart:r.zM()}),nr=r.YO(ni),nl=r.Ik({id:r.ai(),schema:r.Yj(),name:r.Yj(),is_populated:r.zM(),comment:r.Yj().nullable(),columns:f.optional()}),ns=r.YO(nl),nd=r.lq(nl),nm=n=>{let{includeColumns:e}=n;return"\nwith materialized_views as (".concat("\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  c.relispopulated as is_populated,\n  obj_description(c.oid) as comment\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  c.relkind = 'm'\n",")\n  ").concat(e?", columns as (".concat(g,")"):"","\nselect\n  *\n  ").concat(e?", ".concat(u("columns","columns.table_id = materialized_views.id")):"","\nfrom materialized_views")},np=r.Ik({id:r.ai(),schema:r.Yj(),name:r.Yj(),comment:r.Yj().nullable(),foreign_server_name:r.Yj(),foreign_data_wrapper_name:r.Yj(),foreign_data_wrapper_handler:r.Yj(),columns:f.optional()}),nu=r.YO(np),n_=r.lq(np),ng=n=>{let{includeColumns:e}=n;return"\nwith foreign_tables as (".concat("\nselect\n  c.oid::int8 as id,\n  n.nspname as schema,\n  c.relname as name,\n  obj_description(c.oid) as comment,\n  fs.srvname as foreign_server_name,\n  fdw.fdwname as foreign_data_wrapper_name,\n  handler.proname as foreign_data_wrapper_handler\nfrom\n  pg_class c\n  join pg_namespace n on n.oid = c.relnamespace\n  inner join pg_foreign_table ft on ft.ftrelid = c.oid\n  inner join pg_foreign_server fs on fs.oid = ft.ftserver\n  inner join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw\n  inner join pg_proc handler on handler.oid = fdw.fdwhandler\nwhere\n  c.relkind = 'f'\n",")\n  ").concat(e?", columns as (".concat(g,")"):"","\nselect\n  *\n  ").concat(e?", ".concat(u("columns","columns.table_id = foreign_tables.id")):"","\nfrom foreign_tables")},nb=r.Ik({id:r.ai(),schema:r.Yj(),name:r.Yj(),is_updatable:r.zM(),comment:r.Yj().nullable(),columns:f.optional()}),nf=r.YO(nb),nh=r.lq(nb),nE=n=>{let{includeColumns:e}=n;return"\nwith views as (".concat("\nSELECT\n  c.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS name,\n  (pg_relation_is_updatable(c.oid, false) & 20) = 20 AS is_updatable,\n  obj_description(c.oid) AS comment\nFROM\n  pg_class c\n  JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  c.relkind = 'v'\n",")\n  ").concat(e?", columns as (".concat(g,")"):"","\nselect\n  *\n  ").concat(e?", ".concat(u("columns","columns.table_id = views.id")):"","\nfrom views")},nA="\nselect\n  pol.oid :: int8 as id,\n  n.nspname as schema,\n  c.relname as table,\n  c.oid :: int8 as table_id,\n  pol.polname as name,\n  case\n    when pol.polpermissive then 'PERMISSIVE'::text\n    else 'RESTRICTIVE'::text\n  end as action,\n  case\n    when pol.polroles = '{0}'::oid[] then array_to_json(string_to_array('public'::text, ''::text)::name[])\n    else array_to_json(array(\n      select pg_roles.rolname\n      from pg_roles\n      where pg_roles.oid = any(pol.polroles)\n      order by pg_roles.rolname\n    ))\n  end as roles,\n  case pol.polcmd\n    when 'r'::\"char\" then 'SELECT'::text\n    when 'a'::\"char\" then 'INSERT'::text\n    when 'w'::\"char\" then 'UPDATE'::text\n    when 'd'::\"char\" then 'DELETE'::text\n    when '*'::\"char\" then 'ALL'::text\n    else null::text\n  end as command,\n  pg_get_expr(pol.polqual, pol.polrelid) as definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) as check\nfrom\n  pg_policy pol\n  join pg_class c on c.oid = pol.polrelid\n  left join pg_namespace n on n.oid = c.relnamespace\n",nv=r.Ik({id:r.ai(),schema:r.Yj(),table:r.Yj(),table_id:r.ai(),name:r.Yj(),action:r.KC([r.eu("PERMISSIVE"),r.eu("RESTRICTIVE")]),roles:r.YO(r.Yj()),command:r.KC([r.eu("SELECT"),r.eu("INSERT"),r.eu("UPDATE"),r.eu("DELETE"),r.eu("ALL")]),definition:r.KC([r.Yj(),r.ch()]),check:r.KC([r.Yj(),r.ch()])}),nN=r.YO(nv),nT=r.lq(nv),nD="\nSELECT\n  pg_t.oid AS id,\n  pg_t.tgrelid AS table_id,\n  CASE\n    WHEN pg_t.tgenabled = 'D' THEN 'DISABLED'\n    WHEN pg_t.tgenabled = 'O' THEN 'ORIGIN'\n    WHEN pg_t.tgenabled = 'R' THEN 'REPLICA'\n    WHEN pg_t.tgenabled = 'A' THEN 'ALWAYS'\n  END AS enabled_mode,\n  (\n    STRING_TO_ARRAY(\n      ENCODE(pg_t.tgargs, 'escape'), '\\000'\n    )\n  )[:pg_t.tgnargs] AS function_args,\n  is_t.trigger_name AS name,\n  is_t.event_object_table AS table,\n  is_t.event_object_schema AS schema,\n  is_t.action_condition AS condition,\n  is_t.action_orientation AS orientation,\n  is_t.action_timing AS activation,\n  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,\n  pg_p.proname AS function_name,\n  pg_n.nspname AS function_schema\nFROM\n  pg_trigger AS pg_t\nJOIN\n  pg_class AS pg_c\nON pg_t.tgrelid = pg_c.oid\nJOIN information_schema.triggers AS is_t\nON is_t.trigger_name = pg_t.tgname\nAND pg_c.relname = is_t.event_object_table\nAND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace\nJOIN pg_proc AS pg_p\nON pg_t.tgfoid = pg_p.oid\nJOIN pg_namespace AS pg_n\nON pg_p.pronamespace = pg_n.oid\nGROUP BY\n  pg_t.oid,\n  pg_t.tgrelid,\n  pg_t.tgenabled,\n  pg_t.tgargs,\n  pg_t.tgnargs,\n  is_t.trigger_name,\n  is_t.event_object_table,\n  is_t.event_object_schema,\n  is_t.action_condition,\n  is_t.action_orientation,\n  is_t.action_timing,\n  pg_p.proname,\n  pg_n.nspname\n",ny=r.Ik({id:r.ai(),table_id:r.ai(),enabled_mode:r.k5(["DISABLED","ORIGIN","REPLICA","ALWAYS"]),function_args:r.YO(r.Yj()),name:r.Yj(),table:r.Yj(),schema:r.Yj(),condition:r.Yj().nullable(),orientation:r.Yj(),activation:r.Yj(),events:r.YO(r.Yj()),function_name:r.Yj(),function_schema:r.Yj()}),nI=r.YO(ny),nS=r.lq(ny);r.Ik({name:r.Yj(),schema:r.Yj().optional().default("public"),table:r.Yj(),function_schema:r.Yj().optional().default("public"),function_name:r.Yj(),function_args:r.YO(r.Yj()).optional(),activation:r.k5(["BEFORE","AFTER","INSTEAD OF"]),events:r.YO(r.Yj()),orientation:r.k5(["ROW","STATEMENT"]).optional(),condition:r.Yj().optional()}),r.Ik({name:r.Yj().optional(),enabled_mode:r.k5(["ORIGIN","REPLICA","ALWAYS","DISABLED"]).optional()});let nw=r.Ik({id:r.ai(),name:r.Yj(),schema:r.Yj(),format:r.Yj(),enums:r.YO(r.Yj()),attributes:r.YO(r.Ik({name:r.Yj(),type_id:r.ai()})),comment:r.Yj().nullable()}),nj=r.YO(nw),nO=r.Ik({version:r.Yj(),version_number:r.ai(),active_connections:r.ai(),max_connections:r.ai()}),nR="\n  SELECT\n    idx.indexrelid::int8 AS id,\n    idx.indrelid::int8 AS table_id,\n    n.nspname AS schema,\n    idx.indnatts AS number_of_attributes,\n    idx.indnkeyatts AS number_of_key_attributes,\n    idx.indisunique AS is_unique,\n    idx.indisprimary AS is_primary,\n    idx.indisexclusion AS is_exclusion,\n    idx.indimmediate AS is_immediate,\n    idx.indisclustered AS is_clustered,\n    idx.indisvalid AS is_valid,\n    idx.indcheckxmin AS check_xmin,\n    idx.indisready AS is_ready,\n    idx.indislive AS is_live,\n    idx.indisreplident AS is_replica_identity,\n    idx.indkey::smallint[] AS key_attributes,\n    idx.indcollation::integer[] AS collation,\n    idx.indclass::integer[] AS class,\n    idx.indoption::smallint[] AS options,\n    idx.indpred AS index_predicate,\n    obj_description(idx.indexrelid, 'pg_class') AS comment,\n    ix.indexdef as index_definition,\n    am.amname AS access_method,\n    jsonb_agg(\n      jsonb_build_object(\n        'attribute_number', a.attnum,\n        'attribute_name', a.attname,\n        'data_type', format_type(a.atttypid, a.atttypmod)\n      )\n      ORDER BY a.attnum\n    ) AS index_attributes\n  FROM\n    pg_index idx\n    JOIN pg_class c ON c.oid = idx.indexrelid\n    JOIN pg_namespace n ON c.relnamespace = n.oid\n    JOIN pg_am am ON c.relam = am.oid\n    JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(idx.indkey)\n    JOIN pg_indexes ix ON c.relname = ix.indexname\n  GROUP BY\n    idx.indexrelid, idx.indrelid, n.nspname, idx.indnatts, idx.indnkeyatts, idx.indisunique, \n    idx.indisprimary, idx.indisexclusion, idx.indimmediate, idx.indisclustered, idx.indisvalid, \n    idx.indcheckxmin, idx.indisready, idx.indislive, idx.indisreplident, idx.indkey, \n    idx.indcollation, idx.indclass, idx.indoption, idx.indexprs, idx.indpred, ix.indexdef, am.amname\n",nL=r.Ik({id:r.ai(),table_id:r.ai(),schema:r.Yj(),number_of_attributes:r.ai(),number_of_key_attributes:r.ai(),is_unique:r.zM(),is_primary:r.zM(),is_exclusion:r.zM(),is_immediate:r.zM(),is_clustered:r.zM(),is_valid:r.zM(),check_xmin:r.zM(),is_ready:r.zM(),is_live:r.zM(),is_replica_identity:r.zM(),key_attributes:r.YO(r.ai()),collation:r.YO(r.ai()),class:r.YO(r.ai()),options:r.YO(r.ai()),index_predicate:r.Yj().nullable(),comment:r.Yj().nullable(),index_definition:r.Yj(),access_method:r.Yj(),index_attributes:r.YO(r.Ik({attribute_number:r.ai(),attribute_name:r.Yj(),data_type:r.Yj()}))}),nY=r.YO(nL),nC=r.lq(nL),nx=r.Ik({grantor:r.Yj(),grantee:r.Yj(),privilege_type:r.KC([r.eu("SELECT"),r.eu("INSERT"),r.eu("UPDATE"),r.eu("REFERENCES")]),is_grantable:r.zM()}),nk=r.Ik({column_id:r.Yj(),relation_schema:r.Yj(),relation_name:r.Yj(),column_name:r.Yj(),privileges:r.YO(nx)}),nM=r.YO(nk);r.Ik({columnId:r.Yj(),grantee:r.Yj(),privilegeType:r.KC([r.eu("ALL"),r.eu("SELECT"),r.eu("INSERT"),r.eu("UPDATE"),r.eu("REFERENCES")]),isGrantable:r.zM().optional()});let nz={roles:{list:function(){let{includeDefaultRoles:n=!1,limit:e,offset:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a="\nwith\n  roles as (".concat(i,")\nselect\n  *\nfrom\n  roles\nwhere\n  true\n");return n||(a+=" and not pg_catalog.starts_with(name, 'pg_')"),e&&(a+=" limit ".concat(e)),t&&(a+=" offset ".concat(t)),{sql:a,zod:s}},retrieve:function(n){return{sql:"with roles as (".concat(i,") select * from roles where ").concat(m(n),";"),zod:d}},create:function(n){let{name:e,isSuperuser:t=!1,canCreateDb:a=!1,canCreateRole:o=!1,inheritRole:i=!0,canLogin:r=!1,isReplicationRole:l=!1,canBypassRls:s=!1,connectionLimit:d=-1,password:m,validUntil:p,memberOf:u=[],members:_=[],admins:g=[],config:b={}}=n;return{sql:"\ncreate role ".concat((0,c.bD)(e),"\n  ").concat(t?"superuser":"","\n  ").concat(a?"createdb":"","\n  ").concat(o?"createrole":"","\n  ").concat(i?"":"noinherit","\n  ").concat(r?"login":"","\n  ").concat(l?"replication":"","\n  ").concat(s?"bypassrls":"","\n  connection limit ").concat(d,"\n  ").concat(void 0===m?"":"password ".concat((0,c.eu)(m)),"\n  ").concat(void 0===p?"":"valid until ".concat((0,c.eu)(p)),"\n  ").concat(0===u.length?"":"in role ".concat(u.map(c.bD).join(",")),"\n  ").concat(0===_.length?"":"role ".concat(_.map(c.bD).join(",")),"\n  ").concat(0===g.length?"":"admin ".concat(g.map(c.bD).join(",")),"\n  ;\n").concat(Object.entries(b).map(n=>{let[t,a]=n;return"alter role ".concat((0,c.bD)(e)," set ").concat((0,c.bD)(t)," = ").concat((0,c.eu)(a),";")}).join("\n"),"\n")}},update:function(n,e){let{name:t,isSuperuser:a,canCreateDb:o,canCreateRole:r,inheritRole:l,canLogin:s,isReplicationRole:d,canBypassRls:p,connectionLimit:u,password:_,validUntil:g}=e;return{sql:"\ndo $$\ndeclare\n  old record;\nbegin\n  with roles as (".concat(i,")\n  select * into old from roles where ").concat(m(n),";\n  if old is null then\n    raise exception 'Cannot find role with id %', id;\n  end if;\n\n  execute(format('alter role %I\n    ").concat(void 0===a?"":a?"superuser":"nosuperuser","\n    ").concat(void 0===o?"":o?"createdb":"nocreatedb","\n    ").concat(void 0===r?"":r?"createrole":"nocreaterole","\n    ").concat(void 0===l?"":l?"inherit":"noinherit","\n    ").concat(void 0===s?"":s?"login":"nologin","\n    ").concat(void 0===d?"":d?"replication":"noreplication","\n    ").concat(void 0===p?"":p?"bypassrls":"nobypassrls","\n    ").concat(void 0===u?"":"connection limit ".concat(u),"\n    ").concat(void 0===_?"":"password ".concat((0,c.eu)(_)),"\n    ").concat(void 0===g?"":"valid until %L","\n  ', old.name").concat(void 0===g?"":", ".concat((0,c.eu)(g)),"));\n\n  ").concat(void 0===t?"":"\n  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.\n  if ".concat((0,c.eu)(t)," != old.name then\n    execute(format('alter role %I rename to %I;', old.name, ").concat((0,c.eu)(t),"));\n  end if;\n  "),"\nend\n$$;\n")}},remove:function(n){let{ifExists:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"\ndo $$\ndeclare\n  old record;\nbegin\n  with roles as (".concat(i,")\n  select * into old from roles where ").concat(m(n),";\n  if old is null then\n    raise exception 'Cannot find role with id %', id;\n  end if;\n\n  execute(format('drop role ").concat(e?"if exists":""," %I;', old.name));\nend\n$$;\n")}},zod:l},columns:{list:function(){let{tableId:n,includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:a,limit:o,offset:i}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r="\nwith\n  columns as (".concat(g,")\nselect\n  *\nfrom\n  columns\nwhere\n true\n"),l=_(t,a,e?void 0:p.h);return l&&(r+=" and schema ".concat(l)),void 0!==n&&(r+=" and table_id = ".concat((0,c.eu)(n)," ")),o&&(r="".concat(r," limit ").concat(o)),i&&(r="".concat(r," offset ").concat(i)),{sql:r,zod:f}},retrieve:function(n){return{sql:"WITH columns AS (".concat(g,") SELECT * FROM columns WHERE ").concat(function(n){if("id"in n&&n.id)return"".concat((0,c.bD)("id")," = ").concat((0,c.eu)(n.id));if("name"in n&&n.name&&n.schema&&n.table)return"schema = ".concat((0,c.eu)(n.schema)," AND ").concat((0,c.bD)("table")," = ").concat((0,c.eu)(n.table)," AND name = ").concat((0,c.eu)(n.name));throw Error("Must provide either id or schema, name and table")}(n),";"),zod:h}},create:function(n){let{schema:e,table:t,name:a,type:o,default_value:i,default_value_format:r="literal",is_identity:l=!1,identity_generation:s="BY DEFAULT",is_nullable:d,is_primary_key:m=!1,is_unique:p=!1,comment:u,check:_}=n,g="";if(l){if(void 0!==i)throw Error("Columns cannot both be identity and have a default value");g="GENERATED ".concat(s," AS IDENTITY")}else void 0===i||(g="expression"===r?"DEFAULT ".concat(i):"DEFAULT ".concat((0,c.eu)(i)));let b="";void 0!==d&&(b=d?"NULL":"NOT NULL");let f=void 0===u?"":"COMMENT ON COLUMN ".concat((0,c.bD)(e),".").concat((0,c.bD)(t),".").concat((0,c.bD)(a)," IS ").concat((0,c.eu)(u));return{sql:"\nBEGIN;\n  ALTER TABLE ".concat((0,c.bD)(e),".").concat((0,c.bD)(t)," ADD COLUMN ").concat((0,c.bD)(a)," ").concat(E(o),"\n    ").concat(g,"\n    ").concat(b,"\n    ").concat(m?"PRIMARY KEY":"","\n    ").concat(p?"UNIQUE":"","\n    ").concat(void 0===_?"":"CHECK (".concat(_,")"),";\n  ").concat(f,";\nCOMMIT;")}},update:function(n,e){let t,a,{name:o,type:i,drop_default:r=!1,default_value:l,default_value_format:s="literal",is_identity:d,identity_generation:m="BY DEFAULT",is_nullable:p,is_unique:u,comment:_,check:g}=e,b=void 0===o||o===n.name?"":"ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," RENAME COLUMN ").concat((0,c.bD)(n.name)," TO ").concat((0,c.bD)(o),";"),f=void 0===i?"":"ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," ALTER COLUMN ").concat((0,c.bD)(n.name)," SET DATA TYPE ").concat(E(i)," USING ").concat((0,c.bD)(n.name),"::").concat(E(i),";");if(r)t="ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," ALTER COLUMN ").concat((0,c.bD)(n.name)," DROP DEFAULT;");else if(void 0===l)t="";else{let e="expression"===s?l:(0,c.eu)(l);t="ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," ALTER COLUMN ").concat((0,c.bD)(n.name)," SET DEFAULT ").concat(e,";")}let h="ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," ALTER COLUMN ").concat((0,c.bD)(n.name));!1===d?h+=" DROP IDENTITY IF EXISTS;":!0===n.is_identity?void 0===m?h="":h+=" SET GENERATED ".concat(m,";"):void 0===d?h="":h+=" ADD GENERATED ".concat(m," AS IDENTITY;"),a=void 0===p?"":p?"ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," ALTER COLUMN ").concat((0,c.bD)(n.name)," DROP NOT NULL;"):"ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," ALTER COLUMN ").concat((0,c.bD)(n.name)," SET NOT NULL;");let A="";!0===n.is_unique&&!1===u?A="\nDO $$\nDECLARE\n  r record;\nBEGIN\n  FOR r IN\n    SELECT conname FROM pg_constraint WHERE\n      contype = 'u'\n      AND cardinality(conkey) = 1\n      AND conrelid = ".concat((0,c.eu)(n.table_id),"\n      AND conkey[1] = ").concat((0,c.eu)(n.ordinal_position),"\n  LOOP\n    EXECUTE ").concat((0,c.eu)("ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," DROP CONSTRAINT "))," || quote_ident(r.conname);\n  END LOOP;\nEND\n$$;\n"):!1===n.is_unique&&!0===u&&(A="ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," ADD UNIQUE (").concat((0,c.bD)(n.name),");"));let v=void 0===_?"":"COMMENT ON COLUMN ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table),".").concat((0,c.bD)(n.name)," IS ").concat((0,c.eu)(_),";"),N=void 0===g?"":"\nDO $$\nDECLARE\n  v_conname name;\n  v_conkey int2[];\nBEGIN\n  SELECT conname into v_conname FROM pg_constraint WHERE\n    contype = 'c'\n    AND cardinality(conkey) = 1\n    AND conrelid = ".concat((0,c.eu)(n.table_id),"\n    AND conkey[1] = ").concat((0,c.eu)(n.ordinal_position),"\n    ORDER BY oid asc\n    LIMIT 1;\n\n  IF v_conname IS NOT NULL THEN\n    EXECUTE format('ALTER TABLE ").concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," DROP CONSTRAINT %I', v_conname);\n  END IF;\n\n  ").concat(null!==g?"\n  ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," ADD CONSTRAINT ").concat((0,c.bD)("".concat(n.table,"_").concat(n.name,"_check"))," CHECK (").concat(g,");\n\n  SELECT conkey into v_conkey FROM pg_constraint WHERE conname = ").concat((0,c.eu)("".concat(n.table,"_").concat(n.name,"_check")),";\n\n  ASSERT v_conkey IS NOT NULL, 'error creating column constraint: check condition must refer to this column';\n  ASSERT cardinality(v_conkey) = 1, 'error creating column constraint: check condition cannot refer to multiple columns';\n  ASSERT v_conkey[1] = ").concat((0,c.eu)(n.ordinal_position),", 'error creating column constraint: check condition cannot refer to other columns';\n"):"","\nEND\n$$;\n");return{sql:"\nBEGIN;\n  ".concat(a,"\n  ").concat(f,"\n  ").concat(t,"\n  ").concat(h,"\n  ").concat(A,"\n  ").concat(v,"\n  ").concat(N,"\n  ").concat(b,"\nCOMMIT;")}},remove:function(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"ALTER TABLE ".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)," DROP COLUMN ").concat((0,c.bD)(n.name)," ").concat(e?"CASCADE":"RESTRICT",";")}},zod:b},schemas:{list:function(){let{includeSystemSchemas:n=!1,limit:e,offset:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=A;return n||(a="".concat(a," and not (n.nspname in (").concat(p.h.map(c.eu).join(","),"))")),e&&(a="".concat(a," limit ").concat(e)),t&&(a="".concat(a," offset ").concat(t)),{sql:a,zod:N}},retrieve:function(n){let{id:e,name:t}=n;return e?{sql:"".concat(A," and n.oid = ").concat((0,c.eu)(e),";"),zod:T}:{sql:"".concat(A," and n.nspname = ").concat((0,c.eu)(t),";"),zod:T}},create:function(n){let{name:e,owner:t}=n;return{sql:"create schema ".concat((0,c.bD)(e),"\n  ").concat(void 0===t?"":"authorization ".concat((0,c.bD)(t)),";\n")}},update:function(n,e){let{id:t,name:a}=n,{name:o,owner:i}=e;return{sql:"\ndo $$\ndeclare\n  id oid := ".concat(void 0===t?"".concat((0,c.eu)(a),"::regnamespace"):(0,c.eu)(t),";\n  old record;\n  new_name text := ").concat(void 0===o?null:(0,c.eu)(o),";\n  new_owner text := ").concat(void 0===i?null:(0,c.eu)(i),";\nbegin\n  select * into old from pg_namespace where oid = id;\n  if old is null then\n    raise exception 'Cannot find schema with id %', id;\n  end if;\n\n  if new_owner is not null then\n    execute(format('alter schema %I owner to %I;', old.nspname, new_owner));\n  end if;\n\n  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.\n  if new_name is not null and new_name != old.nspname then\n    execute(format('alter schema %I rename to %I;', old.nspname, new_name));\n  end if;\nend\n$$;\n")}},remove:function(n){let{id:e,name:t}=n,{cascade:a=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"\ndo $$\ndeclare\n  id oid := ".concat(void 0===e?"".concat((0,c.eu)(t),"::regnamespace"):(0,c.eu)(e),";\n  old record;\n  cascade bool := ").concat((0,c.eu)(a),";\nbegin\n  select * into old from pg_namespace where oid = id;\n  if old is null then\n    raise exception 'Cannot find schema with id %', id;\n  end if;\n\n  execute(format('drop schema %I %s;', old.nspname, case when cascade then 'cascade' else 'restrict' end));\nend\n$$;\n")}},zod:v},tables:a,functions:o,tablePrivileges:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},c="\nwith table_privileges as (".concat(G,")\nselect *\nfrom table_privileges\n"),i=_(e,t,n?void 0:p.h);return i&&(c+=" where schema ".concat(i)),a&&(c+=" limit ".concat(a)),o&&(c+=" offset ".concat(o)),{sql:c,zod:K}},retrieve:function(n){let{id:e,name:t,schema:a="public"}=n;return e?{sql:"\nwith table_privileges as (".concat(G,")\nselect *\nfrom table_privileges\nwhere table_privileges.relation_id = ").concat((0,c.eu)(e),";"),zod:V}:{sql:"\nwith table_privileges as (".concat(G,")\nselect *\nfrom table_privileges\nwhere table_privileges.schema = ").concat((0,c.eu)(a),"\n  and table_privileges.name = ").concat((0,c.eu)(t),"\n"),zod:V}},grant:function(n){return{sql:"\ndo $$\nbegin\n".concat(n.map(n=>{let{privilegeType:e,relationId:t,grantee:a,isGrantable:o}=n;return"execute format('grant ".concat(e," on table %s to ").concat("public"===a.toLowerCase()?"public":(0,c.bD)(a)," ").concat(o?"with grant option":"","', ").concat(t,"::regclass);")}).join("\n"),"\nend $$;\n")}},revoke:function(n){return{sql:"\ndo $$\nbegin\n".concat(n.map(n=>{let{privilegeType:e,relationId:t,grantee:a}=n;return"execute format('revoke ".concat(e," on table %s from ").concat("public"===a.toLowerCase()?"public":(0,c.bD)(a),"', ").concat(t,"::regclass);")}).join("\n"),"\nend $$;\n")}},zod:J},publications:{list:function(){let{limit:n,offset:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t="with publications as (".concat(X,") select * from publications");return n&&(t+=" limit ".concat(n)),e&&(t+=" offset ".concat(e)),{sql:t,zod:nn}},retrieve:function(n){return{sql:"with publications as (".concat(X,") select * from publications where ").concat(function(n){if("id"in n&&n.id)return"".concat((0,c.bD)("id")," = ").concat((0,c.eu)(n.id));if("name"in n&&n.name)return"".concat((0,c.bD)("name")," = ").concat((0,c.eu)(n.name));throw Error("Must provide either id or name")}(n),";"),zod:ne}},create:function(n){let e,{name:t,publish_insert:a=!1,publish_update:o=!1,publish_delete:i=!1,publish_truncate:r=!1,tables:l=null}=n;e=null==l?"FOR ALL TABLES":0===l.length?"":"FOR TABLE ".concat(l.map(n=>{if(!n.includes("."))return(0,c.bD)(n);let[e,...t]=n.split("."),a=t.join(".");return"".concat((0,c.bD)(e),".").concat((0,c.bD)(a))}).join(","));let s=[];return a&&s.push("insert"),o&&s.push("update"),i&&s.push("delete"),r&&s.push("truncate"),{sql:"\nCREATE PUBLICATION ".concat((0,c.bD)(t)," ").concat(e,"\n  WITH (publish = '").concat(s.join(","),"');")}},update:function(n,e){let{name:t,owner:a,publish_insert:o,publish_update:i,publish_delete:r,publish_truncate:l,tables:s}=e;return{sql:"\ndo $$\ndeclare\n  id oid := ".concat((0,c.eu)(n),";\n  old record;\n  new_name text := ").concat(void 0===t?null:(0,c.eu)(t),";\n  new_owner text := ").concat(void 0===a?null:(0,c.eu)(a),";\n  new_publish_insert bool := ").concat(null!=o?o:null,";\n  new_publish_update bool := ").concat(null!=i?i:null,";\n  new_publish_delete bool := ").concat(null!=r?r:null,";\n  new_publish_truncate bool := ").concat(null!=l?l:null,";\n  new_tables text := ").concat(void 0===s?null:(0,c.eu)(null===s?"all tables":s.map(n=>{if(!n.includes("."))return(0,c.bD)(n);let[e,...t]=n.split("."),a=t.join(".");return"".concat((0,c.bD)(e),".").concat((0,c.bD)(a))}).join(",")),";\nbegin\n  select * into old from pg_publication where oid = id;\n  if old is null then\n    raise exception 'Cannot find publication with id %', id;\n  end if;\n\n  if new_tables is null then\n    null;\n  elsif new_tables = 'all tables' then\n    if old.puballtables then\n      null;\n    else\n      -- Need to recreate because going from list of tables <-> all tables with alter is not possible.\n      execute(format('drop publication %1$I; create publication %1$I for all tables;', old.pubname));\n    end if;\n  else\n    if old.puballtables then\n      -- Need to recreate because going from list of tables <-> all tables with alter is not possible.\n      execute(format('drop publication %1$I; create publication %1$I;', old.pubname));\n    elsif exists(select from pg_publication_rel where prpubid = id) then\n      execute(\n        format(\n          'alter publication %I drop table %s',\n          old.pubname,\n          (select string_agg(prrelid::regclass::text, ', ') from pg_publication_rel where prpubid = id)\n        )\n      );\n    end if;\n\n    -- At this point the publication must have no tables.\n\n    if new_tables != '' then\n      execute(format('alter publication %I add table %s', old.pubname, new_tables));\n    end if;\n  end if;\n\n  execute(\n    format(\n      'alter publication %I set (publish = %L);',\n      old.pubname,\n      concat_ws(\n        ', ',\n        case when coalesce(new_publish_insert, old.pubinsert) then 'insert' end,\n        case when coalesce(new_publish_update, old.pubupdate) then 'update' end,\n        case when coalesce(new_publish_delete, old.pubdelete) then 'delete' end,\n        case when coalesce(new_publish_truncate, old.pubtruncate) then 'truncate' end\n      )\n    )\n  );\n\n  execute(format('alter publication %I owner to %I;', old.pubname, coalesce(new_owner, old.pubowner::regrole::name)));\n\n  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.\n  if new_name is not null and new_name != old.pubname then\n    execute(format('alter publication %I rename to %I;', old.pubname, coalesce(new_name, old.pubname)));\n  end if;\n\n  -- We need to retrieve the publication later, so we need a way to uniquely identify which publication this is.\n  -- We can't rely on id because it gets changed if it got recreated.\n  -- We use a temp table to store the unique name - DO blocks can't return a value.\n  create temp table pg_meta_publication_tmp (name) on commit drop as values (coalesce(new_name, old.pubname));\nend $$;\n")}},remove:function(n){return{sql:"DROP PUBLICATION IF EXISTS ".concat((0,c.bD)(n.name),";")}},zod:Q},extensions:{list:function(){let{limit:n,offset:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=nt;return n&&(t="".concat(t," LIMIT ").concat(n)),e&&(t="".concat(t," OFFSET ").concat(e)),{sql:t,zod:no}},retrieve:function(n){let{name:e}=n;return{sql:"".concat(nt," WHERE name = ").concat((0,c.eu)(e),";"),zod:nc}},create:function(n){let{name:e,schema:t,version:a,cascade:o=!1}=n;return{sql:"\nCREATE EXTENSION ".concat((0,c.bD)(e),"\n  ").concat(void 0===t?"":"SCHEMA ".concat((0,c.bD)(t)),"\n  ").concat(void 0===a?"":"VERSION ".concat((0,c.eu)(a)),"\n  ").concat(o?"CASCADE":"",";")}},update:function(n,e){let{update:t=!1,version:a,schema:o}=e,i="";t&&(i="ALTER EXTENSION ".concat((0,c.bD)(n)," UPDATE ").concat(void 0===a?"":"TO ".concat((0,c.eu)(a)),";"));let r=void 0===o?"":"ALTER EXTENSION ".concat((0,c.bD)(n)," SET SCHEMA ").concat((0,c.bD)(o),";");return{sql:"BEGIN; ".concat(i," ").concat(r," COMMIT;")}},remove:function(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{sql:"DROP EXTENSION ".concat((0,c.bD)(n)," ").concat(e?"CASCADE":"RESTRICT",";")}},zod:na},config:{list:function(){let{limit:n,offset:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t="\nSELECT\n  name,\n  setting,\n  category,\n  TRIM(split_part(category, '/', 1)) AS group,\n  TRIM(split_part(category, '/', 2)) AS subgroup,\n  unit,\n  short_desc,\n  extra_desc,\n  context,\n  vartype,\n  source,\n  min_val,\n  max_val,\n  enumvals,\n  boot_val,\n  reset_val,\n  sourcefile,\n  sourceline,\n  pending_restart\nFROM\n  pg_settings\nORDER BY\n  category,\n  name\n";return n&&(t+=" LIMIT ".concat(n)),e&&(t+=" OFFSET ".concat(e)),{sql:t,zod:nr}},zod:ni},materializedViews:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o,includeColumns:c=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=nm({includeColumns:c}),r=_(e,t,n?void 0:p.h);return r&&(i+=" where schema ".concat(r)),a&&(i+=" limit ".concat(a)),o&&(i+=" offset ".concat(o)),{sql:i,zod:ns}},retrieve:function(n){let e=function(n){if("id"in n&&n.id)return"".concat((0,c.bD)("id")," = ").concat((0,c.eu)(n.id));if("name"in n&&n.name&&n.schema)return"".concat((0,c.bD)("name")," = ").concat((0,c.eu)(n.name)," and ").concat((0,c.bD)("schema")," = ").concat((0,c.eu)(n.schema));throw Error("Must provide either id or name and schema")}(n);return{sql:"".concat(nm({includeColumns:!0})," where ").concat(e,";"),zod:nd}},zod:nl},foreignTables:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o,includeColumns:c=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=ng({includeColumns:c}),r=_(e,t,n?void 0:p.h);return r&&(i+=" where schema ".concat(r)),a&&(i+=" limit ".concat(a)),o&&(i+=" offset ".concat(o)),{sql:i,zod:nu}},retrieve:function(n){return{sql:"".concat(ng({includeColumns:!0})," where ").concat(function(n){if("id"in n&&n.id)return"".concat((0,c.bD)("id")," = ").concat((0,c.eu)(n.id));if("name"in n&&n.name&&n.schema)return"".concat((0,c.bD)("name")," = ").concat((0,c.eu)(n.name)," and ").concat((0,c.bD)("schema")," = ").concat((0,c.eu)(n.schema));throw Error("Must provide either id or name and schema")}(n),";"),zod:n_}},zod:np},views:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o,includeColumns:c=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=nE({includeColumns:c}),r=_(e,t,n?void 0:p.h);return r&&(i+=" where schema ".concat(r)),a&&(i+=" limit ".concat(a)),o&&(i+=" offset ".concat(o)),{sql:i,zod:nf}},retrieve:function(n){let e=function(n){if("id"in n&&n.id)return"".concat((0,c.bD)("id")," = ").concat((0,c.eu)(n.id));if("name"in n&&n.name&&n.schema)return"".concat((0,c.bD)("name")," = ").concat((0,c.eu)(n.name)," and ").concat((0,c.bD)("schema")," = ").concat((0,c.eu)(n.schema));throw Error("Must provide either id or name and schema")}(n);return{sql:"".concat(nE({includeColumns:!0})," where ").concat(e,";"),zod:nh}},zod:nb},policies:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},c="\n    with policies as (".concat(nA,")\n    select *\n    from policies\n    "),i=_(e,t,n?void 0:p.h);return i&&(c+="where schema ".concat(i)),a&&(c+=" limit ".concat(a)),o&&(c+=" offset ".concat(o)),{sql:c,zod:nN}},retrieve:function(n){return{sql:"with policies as (".concat(nA,") select * from policies where ").concat(function(n){if("id"in n&&n.id)return"id = ".concat((0,c.eu)(n.id));if("name"in n&&n.name&&n.schema&&n.table)return"name = ".concat((0,c.eu)(n.name)," AND schema = ").concat((0,c.eu)(n.schema)," AND table = ").concat((0,c.eu)(n.table));throw Error("Must provide either id or name, schema and table")}(n),";"),zod:nT}},create:function(n){let{name:e,schema:t="public",table:a,definition:o,check:i,action:r="PERMISSIVE",command:l="ALL",roles:s=["public"]}=n;return{sql:"\ncreate policy ".concat((0,c.bD)(e)," on ").concat((0,c.bD)(t),".").concat((0,c.bD)(a),"\n  as ").concat(r,"\n  for ").concat(l,"\n  to ").concat(s.map(c.bD).join(","),"\n  ").concat(o?"using (".concat(o,")"):"","\n  ").concat(i?"with check (".concat(i,")"):"",";")}},update:function(n,e){let{name:t,definition:a,check:o,roles:i}=e,r="ALTER POLICY ".concat((0,c.bD)(n.name)," ON ").concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)),l=void 0===t?"":"".concat(r," RENAME TO ").concat((0,c.bD)(t),";"),s=void 0===a?"":"".concat(r," USING (").concat(a,");"),d=void 0===o?"":"".concat(r," WITH CHECK (").concat(o,");"),m=void 0===i?"":"".concat(r," TO ").concat(i.map(c.bD).join(","),";");return{sql:"BEGIN; ".concat(s," ").concat(d," ").concat(m," ").concat(l," COMMIT;")}},remove:function(n){return{sql:"DROP POLICY ".concat((0,c.bD)(n.name)," ON ").concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table),";")}},zod:nv},triggers:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},c="with triggers as (".concat(nD,") select * from triggers"),i=_(e,t,n?void 0:p.h);return i&&(c+=" where schema ".concat(i)),a&&(c+=" limit ".concat(a)),o&&(c+=" offset ".concat(o)),{sql:c,zod:nI}},retrieve:function(n){let e=function(n){if("id"in n&&n.id)return"".concat((0,c.bD)("id")," = ").concat((0,c.eu)(n.id));if("name"in n&&n.name&&n.table&&n.schema)return"".concat((0,c.bD)("name")," = ").concat((0,c.eu)(n.name)," and ").concat((0,c.bD)("schema")," = ").concat((0,c.eu)(n.schema)," and ").concat((0,c.bD)("table")," = ").concat((0,c.eu)(n.table));throw Error("Must provide either id or name, schema and table")}(n);return{sql:"with triggers as (".concat(nD,") select * from triggers where ").concat(e,";"),zod:nS}},create:function(n){let{name:e,schema:t="public",table:a,function_schema:o="public",function_name:i,function_args:l=[],activation:s,events:d,orientation:m,condition:p}=n,u="".concat((0,c.bD)(t),".").concat((0,c.bD)(a)),_="".concat((0,c.bD)(o),".").concat((0,c.bD)(i)),g=d.join(" or "),b=l.map(c.eu).join(",");return{sql:"create trigger ".concat((0,c.bD)(e)," ").concat(s," ").concat(g," on ").concat(u," ").concat(m?"for each ".concat(m):""," ").concat(p?"when (".concat(p,")"):""," execute function ").concat(_,"(").concat(b,");"),zod:r.rI()}},update:function(n,e){let t="".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table)),a="";switch(e.enabled_mode){case"ORIGIN":a="alter table ".concat(t," enable trigger ").concat((0,c.bD)(n.name),";");break;case"DISABLED":a="alter table ".concat(t," disable trigger ").concat((0,c.bD)(n.name),";");break;case"REPLICA":case"ALWAYS":a="alter table ".concat(t," enable ").concat(e.enabled_mode," trigger ").concat((0,c.bD)(n.name),";")}let o=e.name&&e.name!==n.name?"alter trigger ".concat((0,c.bD)(n.name)," on ").concat(t," rename to ").concat((0,c.bD)(e.name),";"):"";return{sql:"begin; ".concat(a,"; ").concat(o,"; commit;"),zod:r.rI()}},remove:function(n){let{cascade:e=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t="".concat((0,c.bD)(n.schema),".").concat((0,c.bD)(n.table));return{sql:"drop trigger ".concat((0,c.bD)(n.name)," on ").concat(t," ").concat(e?"cascade":"",";"),zod:r.rI()}},zod:ny},types:{list:function(){let{includeArrayTypes:n=!1,includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:a,limit:o,offset:c}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i="\nselect\n  t.oid::int8 as id,\n  t.typname as name,\n  n.nspname as schema,\n  format_type (t.oid, null) as format,\n  coalesce(t_enums.enums, '[]') as enums,\n  coalesce(t_attributes.attributes, '[]') as attributes,\n  obj_description (t.oid, 'pg_type') as comment\nfrom\n  pg_type t\n  left join pg_namespace n on n.oid = t.typnamespace\n  left join (\n    select\n      enumtypid,\n      jsonb_agg(enumlabel order by enumsortorder) as enums\n    from\n      pg_enum\n    group by\n      enumtypid\n  ) as t_enums on t_enums.enumtypid = t.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(\n        jsonb_build_object('name', a.attname, 'type_id', a.atttypid::int8)\n        order by a.attnum asc\n      ) as attributes\n    from\n      pg_class c\n      join pg_attribute a on a.attrelid = c.oid\n    where\n      c.relkind = 'c' and not a.attisdropped\n    group by\n      c.oid\n  ) as t_attributes on t_attributes.oid = t.typrelid\nwhere\n  (\n    t.typrelid = 0\n    or (\n      select\n        c.relkind = 'c'\n      from\n        pg_class c\n      where\n        c.oid = t.typrelid\n    )\n  )\n";n||(i+=" and not exists (\n      select from pg_type el\n      where el.oid = t.typelem\n        and el.typarray = t.oid\n    )");let r=_(t,a,e?void 0:p.h);return r&&(i+=" and n.nspname ".concat(r)),o&&(i+=" limit ".concat(o)),c&&(i+=" offset ".concat(c)),{sql:i,zod:nj}},zod:nw},version:{retrieve:function(){return{sql:"\nselect\n  version(),\n  current_setting('server_version_num')::int8 as version_number,\n  (\n    select\n      count(*) as active_connections\n    from\n      pg_stat_activity\n  ) as active_connections,\n  current_setting('max_connections')::int8 as max_connections\n",zod:nO}},zod:nO},indexes:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,limit:a,offset:o}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},c="\n    with indexes as (".concat(nR,")\n    select *\n    from indexes\n  "),i=_(e,t,n?void 0:p.h);return i&&(c+=" where schema ".concat(i)),a&&(c+=" limit ".concat(a)),o&&(c+=" offset ".concat(o)),{sql:c,zod:nY}},retrieve:function(n){let{id:e}=n;return{sql:"\n    with indexes as (".concat(nR,")\n    select *\n    from indexes\n    where id = ").concat((0,c.eu)(e),";\n  "),zod:nC}},zod:nL},columnPrivileges:{list:function(){let{includeSystemSchemas:n=!1,includedSchemas:e,excludedSchemas:t,columnIds:a,limit:o,offset:i}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r="\n  with column_privileges as (".concat("\n-- Lists each column's privileges in the form of:\n--\n-- [\n--   {\n--     \"column_id\": \"12345.1\",\n--     \"relation_schema\": \"public\",\n--     \"relation_name\": \"mytable\",\n--     \"column_name\": \"mycolumn\",\n--     \"privileges\": [\n--       {\n--         \"grantor\": \"postgres\",\n--         \"grantee\": \"myrole\",\n--         \"privilege_type\": \"SELECT\",\n--         \"is_grantable\": false\n--       },\n--       ...\n--     ]\n--   },\n--   ...\n-- ]\n--\n-- Modified from information_schema.column_privileges. We try to be as close as\n-- possible to the view definition, obtained from:\n--\n-- select pg_get_viewdef('information_schema.column_privileges');\n--\n-- The main differences are:\n-- - we include column privileges for materialized views\n--   (reason for exclusion in information_schema.column_privileges:\n--    https://www.postgresql.org/message-id/9136.1502740844%40sss.pgh.pa.us)\n-- - we query a.attrelid and a.attnum to generate column_id\n-- - table_catalog is omitted\n-- - table_schema -> relation_schema, table_name -> relation_name\n--\n-- Column privileges are intertwined with table privileges in that table\n-- privileges override column privileges. E.g. if we do:\n--\n-- grant all on mytable to myrole;\n--\n-- Then myrole is granted privileges for ALL columns. Likewise, if we do:\n--\n-- grant all (id) on mytable to myrole;\n-- revoke all on mytable from myrole;\n--\n-- Then the grant on the id column is revoked.\n--\n-- This is unlike how grants for schemas and tables interact, where you need\n-- privileges for BOTH the schema the table is in AND the table itself in order\n-- to access the table.\n\nselect (x.attrelid || '.' || x.attnum) as column_id,\n       nc.nspname as relation_schema,\n       x.relname as relation_name,\n       x.attname as column_name,\n       coalesce(\n         jsonb_agg(\n           jsonb_build_object(\n             'grantor', u_grantor.rolname,\n             'grantee', grantee.rolname,\n             'privilege_type', x.prtype,\n             'is_grantable', x.grantable\n           )\n         ),\n         '[]'\n       ) as privileges\nfrom\n  (select pr_c.grantor,\n          pr_c.grantee,\n          a.attrelid,\n          a.attnum,\n          a.attname,\n          pr_c.relname,\n          pr_c.relnamespace,\n          pr_c.prtype,\n          pr_c.grantable,\n          pr_c.relowner\n   from\n     (select pg_class.oid,\n             pg_class.relname,\n             pg_class.relnamespace,\n             pg_class.relowner,\n             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).grantor as grantor,\n             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).grantee as grantee,\n             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).privilege_type as privilege_type,\n             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).is_grantable as is_grantable\n      from pg_class\n      where (pg_class.relkind = any (array['r',\n                                           'v',\n                                           'm',\n                                           'f',\n                                           'p'])) ) pr_c(oid, relname, relnamespace, relowner, grantor, grantee, prtype, grantable),\n                                                    pg_attribute a\n   where ((a.attrelid = pr_c.oid)\n          and (a.attnum > 0)\n          and (not a.attisdropped))\n   union select pr_a.grantor,\n                pr_a.grantee,\n                pr_a.attrelid,\n                pr_a.attnum,\n                pr_a.attname,\n                c.relname,\n                c.relnamespace,\n                pr_a.prtype,\n                pr_a.grantable,\n                c.relowner\n   from\n     (select a.attrelid,\n             a.attnum,\n             a.attname,\n             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).grantor as grantor,\n             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).grantee as grantee,\n             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).privilege_type as privilege_type,\n             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).is_grantable as is_grantable\n      from (pg_attribute a\n            join pg_class cc on ((a.attrelid = cc.oid)))\n      where ((a.attnum > 0)\n             and (not a.attisdropped))) pr_a(attrelid, attnum, attname, grantor, grantee, prtype, grantable),\n                                        pg_class c\n   where ((pr_a.attrelid = c.oid)\n          and (c.relkind = any (ARRAY['r',\n                                      'v',\n                                      'm',\n                                      'f',\n                                      'p'])))) x,\n     pg_namespace nc,\n     pg_authid u_grantor,\n  (select pg_authid.oid,\n          pg_authid.rolname\n   from pg_authid\n   union all select (0)::oid as oid,\n                    'PUBLIC') grantee(oid, rolname)\nwhere ((x.relnamespace = nc.oid)\n       and (x.grantee = grantee.oid)\n       and (x.grantor = u_grantor.oid)\n       and (x.prtype = any (ARRAY['INSERT',\n                                  'SELECT',\n                                  'UPDATE',\n                                  'REFERENCES']))\n       and (pg_has_role(u_grantor.oid, 'USAGE')\n            or pg_has_role(grantee.oid, 'USAGE')\n            or (grantee.rolname = 'PUBLIC')))\ngroup by column_id,\n         nc.nspname,\n         x.relname,\n         x.attname\n",")\n  select *\n  from column_privileges\n  "),l=[],s=_(e,t,n?void 0:p.h);return s&&l.push("relation_schema ".concat(s)),(null==a?void 0:a.length)&&l.push("column_id in (".concat(a.map(c.eu).join(","),")")),l.length>0&&(r+=" where ".concat(l.join(" and "))),o&&(r+=" limit ".concat(o)),i&&(r+=" offset ".concat(i)),{sql:r,zod:nM}},grant:function(n){return{sql:"\ndo $$\ndeclare\n  col record;\nbegin\n".concat(n.map(n=>{let{privilegeType:e,columnId:t,grantee:a,isGrantable:o}=n,[i,r]=t.split(".");return"\nselect *\nfrom pg_attribute a\nwhere a.attrelid = ".concat((0,c.eu)(i),"\n  and a.attnum = ").concat((0,c.eu)(r),"\ninto col;\nexecute format(\n  'grant ").concat(e," (%I) on %s to ").concat("public"===a.toLowerCase()?"public":(0,c.bD)(a)," ").concat(o?"with grant option":"","',\n  col.attname,\n  col.attrelid::regclass\n);")}).join("\n"),"\nend $$;\n")}},revoke:function(n){return{sql:"\ndo $$\ndeclare\n  col record;\nbegin\n".concat(n.map(n=>{let{privilegeType:e,columnId:t,grantee:a}=n,[o,i]=t.split(".");return"\nselect *\nfrom pg_attribute a\nwhere a.attrelid = ".concat((0,c.eu)(o),"\n  and a.attnum = ").concat((0,c.eu)(i),"\ninto col;\nexecute format(\n  'revoke ").concat(e," (%I) on %s from ").concat("public"===a.toLowerCase()?"public":(0,c.bD)(a),"',\n  col.attname,\n  col.attrelid::regclass\n);")}).join("\n"),"\nend $$;\n")}},zod:nk},query:t(76984)}}}]);