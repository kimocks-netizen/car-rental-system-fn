try{!function(){var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="d9516638-a785-4a09-a486-6550c1171a4a",e._sentryDebugIdIdentifier="sentry-dbid-d9516638-a785-4a09-a486-6550c1171a4a")}()}catch(e){}"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[63335],{17299:(e,n,t)=>{t.d(n,{Ax:()=>s,DH:()=>c,WV:()=>o,_m:()=>r,vN:()=>i});var a=t(65471);let s=e=>{let n=new Set(e.filter(e=>e.required).map(e=>e.name)),t=new Set(Array.from(n).filter(e=>e.includes("."))),a=Array.from(t);return e=>Object.fromEntries(Object.entries(e).flatMap(e=>{let[n,t]=e;return Array.isArray(t)?[[n,t],...t.map((e,t)=>["".concat(n,".").concat(t),e])]:[[n,t]]}).filter(e=>{let[s,r]=e,[o,i]=s.split(".");if(void 0!==i&&n.has(o)&&Object.keys(r).some(e=>t.has("".concat(o,".").concat(e)))){let e=a.find(e=>e.startsWith("".concat(o,".")));return!!e&&!r[e.split(".")[1]]}return n.has(o)&&(Array.isArray(r)?r.length<1:!r)}).map(e=>{let[n]=e;return"table_name"===n?[n,"Please provide a name for your table"]:"columns"===n?[n,"Please select at least one column"]:[n,"This field is required"]}))},r=(e,n)=>{var t;return(null!=(t=null==e?void 0:e.tables)?t:[]).map(t=>{var s,r,o;let i=0,c=Object.fromEntries(t.options.map(e=>e.split("=")));switch(e.handler){case a.Ur.STRIPE:i=null!=(s=null==n?void 0:n.tables.findIndex(e=>{var n;return(null==(n=e.options.find(e=>"object"===e.name))?void 0:n.defaultValue)===c.object}))?s:0;break;case a.Ur.FIREBASE:i="auth/users"===c.object?null!=(r=null==n?void 0:n.tables.findIndex(e=>e.options.find(e=>"auth/users"===e.defaultValue)))?r:0:null!=(o=null==n?void 0:n.tables.findIndex(e=>"Firestore Collection"===e.label))?o:0;case a.Ur.S3:case a.Ur.AIRTABLE:case a.Ur.LOGFLARE:case a.Ur.BIG_QUERY:case a.Ur.CLICK_HOUSE:}return{...c,index:i,id:t.id,columns:t.columns,is_new_schema:!1,schema:t.schema,schema_name:t.schema,table_name:t.name}})},o=e=>Object.fromEntries(e.map(e=>e.split("=")));function i(e,n){if("wasm_fdw_handler"===e.handlerName){var t,a;let s=o(null!=(a=null==n?void 0:n.server_options)?a:[]);return(null==(t=e.server.options.find(e=>"fdw_package_name"===e.name))?void 0:t.defaultValue)===s.fdw_package_name}return e.handlerName===(null==n?void 0:n.handler)}function c(e){return a.V4.find(n=>i(n,e))}},40805:(e,n,t)=>{t.d(n,{RB:()=>o,ov:()=>i});var a=t(67850),s=t(59356),r=t(56748);async function o(e,n){let{projectRef:t,connectionString:a}=e,{result:r}=await (0,s.E)({projectRef:t,connectionString:a,sql:"\n    select\n      s.oid as \"id\",\n      w.fdwname as \"name\",\n      s.srvname as \"server_name\",\n      s.srvoptions as \"server_options\",\n      c.proname as \"handler\",\n      (\n        select jsonb_agg(\n          jsonb_build_object(\n            'id', c.oid::bigint,\n            'schema', relnamespace::regnamespace::text,\n            'name', c.relname,\n            'columns', (\n              select jsonb_agg(\n                jsonb_build_object(\n                  'name', a.attname,\n                  'type', pg_catalog.format_type(a.atttypid, a.atttypmod)\n                )\n              )\n              from pg_catalog.pg_attribute a\n              where a.attrelid = c.oid and a.attnum > 0 and not a.attisdropped\n            ),\n            'options', t.ftoptions\n          )\n        )\n        from pg_catalog.pg_class c\n        join pg_catalog.pg_foreign_table t on c.oid = t.ftrelid\n        where c.oid = any (select t.ftrelid from pg_catalog.pg_foreign_table t where t.ftserver = s.oid)\n      ) as \"tables\"\n    from pg_catalog.pg_foreign_server s\n    join pg_catalog.pg_foreign_data_wrapper w on s.srvfdw = w.oid\n    join pg_catalog.pg_proc c on w.fdwhandler = c.oid;\n  ",queryKey:["fdws"]},n);return r}let i=function(e){let{projectRef:n,connectionString:t}=e,{enabled:s=!0,...i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(0,a.I)({queryKey:r.Y.list(n),queryFn:e=>{let{signal:a}=e;return o({projectRef:n,connectionString:t},a)},enabled:s&&void 0!==n,...i})}},63335:(e,n,t)=>{t.d(n,{$O:()=>g,BQ:()=>f,Uu:()=>p});var a=t(74722),s=t.n(a),r=t(86727),o=t.n(r),i=t(53239),c=t(65471),l=t(17299),u=t(74809),m=t(40805),d=t(9620);let g=["auth","cron","extensions","information_schema","net","pgsodium","pgsodium_masks","pgbouncer","pgtle","realtime","storage","supabase_functions","supabase_migrations","vault","graphql","graphql_public",u.Lh],p=function(){let{excludeSchemas:e=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=(0,i.useMemo)(()=>e,[JSON.stringify(e)]),t=(()=>{let{data:e}=(0,d.YA)(),n=(0,m.ov)({projectRef:null==e?void 0:e.ref,connectionString:null==e?void 0:e.connectionString}),t=(0,i.useMemo)(()=>c.V4.filter(e=>e.server.options.some(e=>e.name===c.xZ.name)),[]),a=(0,i.useMemo)(()=>{var e,a;return(null!=(a=null==(e=n.data)?void 0:e.filter(e=>t.some(n=>(0,l.vN)(n,e))))?a:[]).map(e=>{var n;let t=null!=(n=(0,l.WV)(e.server_options).supabase_target_schema)?n:"",a=s()(t.split(",").filter(Boolean));return{serverName:e.server_name,type:e.handler.replace("_fdw_handler",""),schemas:a}})},[n.data,t]);return{...n,data:a}})(),a=(0,i.useMemo)(()=>{var e;let a=g.map(e=>({name:e,type:"internal"})),s=null==(e=t.data)?void 0:e.flatMap(e=>e.schemas.map(n=>({name:n,type:"fdw",fdwType:e.type,serverName:e.serverName})));return o()([...a,...s],e=>e.name).filter(e=>!n.includes(e.name))},[t.data,n]);return{...t,data:a}},f=e=>{let{schema:n,excludedSchemas:t=[]}=e,{data:a}=p({excludeSchemas:t}),s=a.find(e=>e.name===n);return s?{isSchemaLocked:!0,reason:s.type,fdwType:s.fdwType}:{isSchemaLocked:!1,reason:void 0,fdwType:void 0}}},74809:(e,n,t)=>{t.d(n,{Lh:()=>p,T_:()=>h});var a=t(51355),s=t(80210),r=t(26616),o=t.n(r),i=t(73969),c=t(32510),l=t(59356);function u(e){if(!e||"string"!=typeof e)return null;let n=e.trim().split(".");if(3!==n.length)return null;let t=parseInt(n[0],10),a=parseInt(n[1],10),s=parseInt(n[2],10);return isNaN(t)||isNaN(a)||isNaN(s)||t<0||a<0||s<0?null:{major:t,minor:a,patch:s}}function m(e,n){let t=function(e,n){let t=u(e),a=u(n);return t&&a?t.major!==a.major?t.major>a.major?1:-1:t.minor!==a.minor?t.minor>a.minor?1:-1:t.patch!==a.patch?t.patch>a.patch?1:-1:0:null}(e,n);return 1===t||0===t}var d=t(95341);let g="1.5.0",p="pgmq_public",f=o()("\n  drop function if exists \n    ".concat(p,".pop(queue_name text),\n    ").concat(p,".send(queue_name text, message jsonb, sleep_seconds integer),\n    ").concat(p,".send_batch(queue_name text, message jsonb[], sleep_seconds integer),\n    ").concat(p,".archive(queue_name text, message_id bigint),\n    ").concat(p,".delete(queue_name text, message_id bigint),\n    ").concat(p,".read(queue_name text, sleep integer, n integer)\n  ;\n\n  -- Revoke execute permissions on inner pgmq functions to roles (inverse of enabling)\n  do $$\n  begin\n      if exists (select 1 from pg_namespace where nspname = 'pgmq') then\n          -- Revoke privileges on the schema itself\n          revoke all on schema pgmq from anon, authenticated, service_role;\n          \n          -- Revoke default privileges for future objects\n          alter default privileges in schema pgmq revoke all on tables from anon, authenticated, service_role;\n          alter default privileges in schema pgmq revoke all on sequences from anon, authenticated, service_role;\n          alter default privileges in schema pgmq revoke all on functions from anon, authenticated, service_role;\n      end if;\n  end $$;\n\n  drop schema if exists ").concat(p,";\n"));async function _(e){let{projectRef:n,pgmqVersion:t,connectionString:a,enable:s}=e,r=s?(e=>{let n=m(e,g)?", conditional := '{}'::jsonb":"",t=m(e,g)?", jsonb":"";return o()("\n  create schema if not exists ".concat(p,";\n  grant usage on schema ").concat(p," to postgres, anon, authenticated, service_role;\n\n  create or replace function ").concat(p,".pop(\n      queue_name text\n  )\n    returns setof pgmq.message_record\n    language plpgsql\n    set search_path = ''\n  as $$\n  begin\n      return query\n      select *\n      from pgmq.pop(\n          queue_name := queue_name\n      );\n  end;\n  $$;\n\n  comment on function ").concat(p,".pop(queue_name text) is 'Retrieves and locks the next message from the specified queue.';\n\n\n  create or replace function ").concat(p,".send(\n      queue_name text,\n      message jsonb,\n      sleep_seconds integer default 0  -- renamed from 'delay'\n  )\n    returns setof bigint\n    language plpgsql\n    set search_path = ''\n  as $$\n  begin\n      return query\n      select *\n      from pgmq.send(\n          queue_name := queue_name,\n          msg := message,\n          delay := sleep_seconds\n      );\n  end;\n  $$;\n\n  comment on function ").concat(p,".send(queue_name text, message jsonb, sleep_seconds integer) is 'Sends a message to the specified queue, optionally delaying its availability by a number of seconds.';\n\n\n  create or replace function ").concat(p,".send_batch(\n      queue_name text,\n      messages jsonb[],\n      sleep_seconds integer default 0  -- renamed from 'delay'\n  )\n    returns setof bigint\n    language plpgsql\n    set search_path = ''\n  as $$\n  begin\n      return query\n      select *\n      from pgmq.send_batch(\n          queue_name := queue_name,\n          msgs := messages,\n          delay := sleep_seconds\n      );\n  end;\n  $$;\n\n  comment on function ").concat(p,".send_batch(queue_name text, messages jsonb[], sleep_seconds integer) is 'Sends a batch of messages to the specified queue, optionally delaying their availability by a number of seconds.';\n\n\n  create or replace function ").concat(p,".archive(\n      queue_name text,\n      message_id bigint\n  )\n    returns boolean\n    language plpgsql\n    set search_path = ''\n  as $$\n  begin\n      return\n      pgmq.archive(\n          queue_name := queue_name,\n          msg_id := message_id\n      );\n  end;\n  $$;\n\n  comment on function ").concat(p,".archive(queue_name text, message_id bigint) is 'Archives a message by moving it from the queue to a permanent archive.';\n\n\n  create or replace function ").concat(p,".delete(\n      queue_name text,\n      message_id bigint\n  )\n    returns boolean\n    language plpgsql\n    set search_path = ''\n  as $$\n  begin\n      return\n      pgmq.delete(\n          queue_name := queue_name,\n          msg_id := message_id\n      );\n  end;\n  $$;\n\n  comment on function ").concat(p,".delete(queue_name text, message_id bigint) is 'Permanently deletes a message from the specified queue.';\n\n  create or replace function ").concat(p,".read(\n      queue_name text,\n      sleep_seconds integer,\n      n integer\n  )\n    returns setof pgmq.message_record\n    language plpgsql\n    set search_path = ''\n  as $$\n  begin\n      return query\n      select *\n      from pgmq.read(\n          queue_name := queue_name,\n          vt := sleep_seconds,\n          qty := n ").concat(n,"\n      );\n  end;\n  $$;\n\n  comment on function ").concat(p,'.read(queue_name text, sleep_seconds integer, n integer) is \'Reads up to "n" messages from the specified queue with an optional "sleep_seconds" (visibility timeout).\';\n\n  -- Grant execute permissions on wrapper functions to roles\n  grant execute on function ').concat(p,".pop(text) to postgres, service_role, anon, authenticated;\n  grant execute on function pgmq.pop(text) to postgres, service_role, anon, authenticated;\n\n  grant execute on function ").concat(p,".send(text, jsonb, integer) to postgres, service_role, anon, authenticated;\n  grant execute on function pgmq.send(text, jsonb, integer) to postgres, service_role, anon, authenticated;\n\n  grant execute on function ").concat(p,".send_batch(text, jsonb[], integer) to postgres, service_role, anon, authenticated;\n  grant execute on function pgmq.send_batch(text, jsonb[], integer) to postgres, service_role, anon, authenticated;\n\n  grant execute on function ").concat(p,".archive(text, bigint) to postgres, service_role, anon, authenticated;\n  grant execute on function pgmq.archive(text, bigint) to postgres, service_role, anon, authenticated;\n\n  grant execute on function ").concat(p,".delete(text, bigint) to postgres, service_role, anon, authenticated;\n  grant execute on function pgmq.delete(text, bigint) to postgres, service_role, anon, authenticated;\n\n  grant execute on function ").concat(p,".read(text, integer, integer) to postgres, service_role, anon, authenticated;\n  grant execute on function pgmq.read(text, integer, integer ").concat(t,") to postgres, service_role, anon, authenticated;\n\n  -- For the service role, we want full access\n  -- Grant permissions on existing tables\n  grant all privileges on all tables in schema pgmq to postgres, service_role;\n\n  -- Ensure service_role has permissions on future tables\n  alter default privileges in schema pgmq grant all privileges on tables to postgres, service_role;\n\n  grant usage on schema pgmq to postgres, anon, authenticated, service_role;\n\n\n  /*\n    Grant access to sequences to API roles by default. Existing table permissions\n    continue to enforce insert restrictions. This is necessary to accommodate the\n    on-backup hook that rebuild queue table primary keys to avoid a pg_dump segfault.\n    This can be removed once logical backups are completely retired.\n  */\n  grant usage, select, update\n  on all sequences in schema pgmq\n  to anon, authenticated, service_role;\n\n  alter default privileges in schema pgmq\n  grant usage, select, update\n  on sequences\n  to anon, authenticated, service_role;\n"))})(t):f,{result:i}=await (0,l.E)({projectRef:n,connectionString:a,sql:r,queryKey:["toggle-queues-exposure"]});return i}let h=function(){let{onSuccess:e,onError:n,...t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=(0,a.jE)();return(0,s.n)({mutationFn:e=>_(e),async onSuccess(n,t,a){let{projectRef:s}=t;await r.invalidateQueries({queryKey:d.m.exposePostgrestStatus(s)}),r.invalidateQueries({queryKey:c.c.schemas(s)}),await (null==e?void 0:e(n,t,a))},async onError(e,t,a){void 0===n?i.oR.error("Failed to toggle queue exposure via PostgREST: ".concat(e.message)):n(e,t,a)},...t})}},95341:(e,n,t)=>{t.d(n,{m:()=>a});let a={create:()=>["queues","create"],delete:e=>["queues",e,"delete"],purge:e=>["queues",e,"purge"],getMessagesInfinite:(e,n,t)=>["projects",e,"queue-messages",n,t].filter(Boolean),list:e=>["projects",e,"queues"],metrics:(e,n)=>["projects",e,"queue-metrics",n],exposePostgrestStatus:e=>["projects",e,"queue-expose-status"]}}}]);